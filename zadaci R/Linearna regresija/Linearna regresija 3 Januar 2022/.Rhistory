data <- read.csv("medals.csv", stringsAsFactors = F)
str(data)
data <- read.csv("medals.csv", stringsAsFactors = T)
str(data)
data <- read.csv("medals.csv")
str(data)
data <- read.csv("medals.csv", stringsAsFactors = F)
str(data)
View(data)
sum(is.na(data$Team.NOC))
sum(data$Team.NOC == "", na.rm = T)
sum(data$Team.NOC == "-", na.rm = T)
sum(data$Team.NOC == " ", na.rm = T)
data <- subset(data, data$Team.NOC != "")
data <- subset(data, data$Team.NOC != "-")
str(data)
length(unique(data$Team.NOC))
data$Team.NOC <- NULL
apply(dataSub, MARGIN = 2, FUN = function(x) sum(is.na(x)))
apply(data, MARGIN = 2, FUN = function(x) sum(is.na(x)))
apply(data, MARGIN = 2, FUN = function(x) sum(x == "", na.rm = T))
apply(data, MARGIN = 2, FUN = function(x) sum(x == "N/A", na.rm = T))
apply(data, MARGIN = 2, FUN = function(x) sum(x == "-", na.rm = T))
apply(data, MARGIN = 2, FUN = function(x) sum(x == " ", na.rm = T))
data <- data[complete.cases(data[,1]),]
# sredjujemo silver, gledamo da li ima normalnu raspodelu ili nema
# pa u odnosu nedostajucu vrednost menjamo srednjom vrednoscu ili medijanom
shapiro.test(data$Silver)
data$Silver[data$Silver == "-"] <- NA
data$Silver <- as.numeric(data$Silver)
shapiro.test(data$Silver)
medianSilver <- median(data$Silver, na.rm = T)
data$Silver[is.na(data$Silver)] <- medianSilver
apply(data, MARGIN = 2, FUN = function(x) sum(is.na(x)))
apply(data, MARGIN = 2, FUN = function(x) sum(x == "", na.rm = T))
apply(data, MARGIN = 2, FUN = function(x) sum(x == "-", na.rm = T))
apply(data, MARGIN = 2, FUN = function(x) sum(x == " ", na.rm = T))
matrica <- cor(data)
library(corrplot)
corrplot(data, method = "number", type = "upper", diag = F)
corrplot(matrica, method = "number", type = "upper", diag = F)
library(caret)
set.seed(1010)
indexes <- createDataPartition(data$Gold, p = 0.8, list = FALSE)
train.data <- dataSub[indexes, ]
test.data <- dataSub[-indexes, ]
train.data <- data[indexes, ]
test.data <- data[-indexes, ]
lm1 <- lm(Gold ~ ., data = train.data)
lm1
summary(lm1)
library(car)
vif(lm1)
sqrt(vif(lm1))
# pravimo 4 plota
graphics.off()
par(mfrow = c(1,1)) # da imamo samo 1 red i 1 kolonu za grafove
par(mfrow = c(2,2)) # da imamo 2 reda i 2 kolone za grafove
plot(lm1)
lm2 <- lm(Gold ~ Silver, data = train.data)
summary(lm2)
lm2 <- lm(Gold ~ Bronze, data = train.data)
summary(lm2)
lm2 <- lm(Gold ~ Bronze, data = train.data)
summary(lm2)
lm3 <- lm(Gold ~ Silver, data = train.data)
summary(lm3)
graphics.off()
par(mfrow = c(1,1))
par(mfrow = c(2,2))
plot(lm3)
lm3.pred <- predict(lm3, newdata = test.data)
head(lm3.pred)
head(test.data$User_Score)
# mozete da da koristite ovaj ggplot, ali nije neophodno
test.data$User_Score_pred <- lm3.pred
# mozete da da koristite ovaj ggplot, ali nije neophodno
test.data$User_Score_pred <- NULL
# mozete da da koristite ovaj ggplot, ali nije neophodno
test.data$Gold_pred <- lm3.pred
library(ggplot2)
ggplot(test.data) +
geom_density(aes(x = User_Score, color = 'actual')) +
geom_density(aes(x = User_Score_pred, color = 'predicted'))
library(ggplot2)
ggplot(test.data) +
geom_density(aes(x = Gold, color = 'actual')) +
geom_density(aes(x = Gold_pred, color = 'predicted'))
View(test.data)
lm3.pred <- predict(lm1, newdata = test.data)
head(lm3.pred)
head(test.data$Gold)
# mozete da da koristite ovaj ggplot, ali nije neophodno
test.data$Gold_pred <- lm3.pred
library(ggplot2)
ggplot(test.data) +
geom_density(aes(x = Gold, color = 'actual')) +
geom_density(aes(x = Gold_pred, color = 'predicted'))
lm3.pred <- predict(lm3, newdata = test.data)
head(lm3.pred)
head(test.data$Gold)
# mozete da da koristite ovaj ggplot, ali nije neophodno
test.data$Gold_pred <- lm3.pred
library(ggplot2)
ggplot(test.data) +
geom_density(aes(x = Gold, color = 'actual')) +
geom_density(aes(x = Gold_pred, color = 'predicted'))
RSS <- sum((lm3.pred - test.data$Gold)^2)
# razlika izmedju vrednosti u testu i srednje vrednosti u trainu,
# nju sumiramo i kvadriramo da bismo dobili TSS
TSS <- sum((mean(train.data$Gold) - test.data$Gold)^2)
# ovo je formula za RSQUARED
rsquared <- 1 - RSS / TSS
rsquared
summary(lm3)
# RMSE = Root Mean Squared Error, koliku gresku pravimo s predikcijama
# RSS / broj observacija u test setu
RMSE <- sqrt(RSS/nrow(test.data))
RMSE
# OVO NEMA U CHEATSHEETU !
mean(test.data$Gold) # mean, srednja vrednost nam je 7.3 poena
RMSE/mean(test.data$Gold)
lm3.pred <- predict(lm1, newdata = test.data)
head(lm3.pred)
head(test.data$Gold)
# mozete da da koristite ovaj ggplot, ali nije neophodno
test.data$Gold_pred <- lm3.pred
library(ggplot2)
ggplot(test.data) +
geom_density(aes(x = Gold, color = 'actual')) +
geom_density(aes(x = Gold_pred, color = 'predicted'))
RSS <- sum((lm3.pred - test.data$Gold)^2)
# razlika izmedju vrednosti u testu i srednje vrednosti u trainu,
# nju sumiramo i kvadriramo da bismo dobili TSS
TSS <- sum((mean(train.data$Gold) - test.data$Gold)^2)
# ovo je formula za RSQUARED
rsquared <- 1 - RSS / TSS
rsquared
summary(lm3)
# RMSE = Root Mean Squared Error, koliku gresku pravimo s predikcijama
# RSS / broj observacija u test setu
RMSE <- sqrt(RSS/nrow(test.data))
RMSE
# OVO NEMA U CHEATSHEETU !
mean(test.data$Gold) # mean, srednja vrednost nam je 2.941 poena
RMSE/mean(test.data$Gold)
lm1.pred <- predict(lm1, newdata = test.data)
head(lm1.pred)
head(test.data$Gold)
# mozete da da koristite ovaj ggplot, ali nije neophodno
test.data$Gold_pred <- lm1.pred
library(ggplot2)
ggplot(test.data) +
geom_density(aes(x = Gold, color = 'actual')) +
geom_density(aes(x = Gold_pred, color = 'predicted'))
RSS <- sum((lm1.pred - test.data$Gold)^2)
# razlika izmedju vrednosti u testu i srednje vrednosti u trainu,
# nju sumiramo i kvadriramo da bismo dobili TSS
TSS <- sum((mean(train.data$Gold) - test.data$Gold)^2)
# ovo je formula za RSQUARED
rsquared <- 1 - RSS / TSS
rsquared
summary(lm1)
# RMSE = Root Mean Squared Error, koliku gresku pravimo s predikcijama
# RSS / broj observacija u test setu
RMSE <- sqrt(RSS/nrow(test.data))
RMSE
# OVO NEMA U CHEATSHEETU !
mean(test.data$Gold) # mean, srednja vrednost nam je 2.941 poena
RMSE/mean(test.data$Gold)
data <- read.csv("medals.csv", stringsAsFactors = F)
str(data)
# proveravamo koje nedostajuce vrednosti ima
sum(is.na(data$Team.NOC))
sum(data$Team.NOC == "", na.rm = T)
sum(data$Team.NOC == "-", na.rm = T)
sum(data$Team.NOC == " ", na.rm = T)
# pravimo podskup
data <- subset(data, data$Team.NOC != "-")
str(data)
length(unique(data$Team.NOC))
# naziv drzave nam nije potreban za linearnu regresiju, a Silver cemo pretvoriti
# u numericku varijablu, ali prvo da pogledamo koje su nedostajuce vrednosti
data$Team.NOC <- NULL
apply(data, MARGIN = 2, FUN = function(x) sum(is.na(x)))
apply(data, MARGIN = 2, FUN = function(x) sum(x == "", na.rm = T))
apply(data, MARGIN = 2, FUN = function(x) sum(x == "-", na.rm = T))
apply(data, MARGIN = 2, FUN = function(x) sum(x == " ", na.rm = T))
# Gold je izlazna varijabla i ima dve nedostajuce vrednosti
# posto je izlazna, te dve observacije moramo da uklonimo iz dataseta
# Silver ima jedan "-", pa cemo to zameniti adekvatnijom vrednoscu
data <- data[complete.cases(data[,1]),]
# izbacili smo dve nedostajuce vrednosti iz Gold
# sredjujemo silver, gledamo da li ima normalnu raspodelu ili nema
# pa u odnosu nedostajucu vrednost menjamo srednjom vrednoscu ili medijanom
# ali prvo moramo sve te "-" da pretvorimo u NA vrednosti da bismo
# varijablu pretvorili u numeric jer je trenutno character
data$Silver[data$Silver == "-"] <- NA
data$Silver <- as.numeric(data$Silver)
shapiro.test(data$Silver)
# nema normalnu raspodelu, menjamo medijanom
medianSilver <- median(data$Silver, na.rm = T)
data$Silver[is.na(data$Silver)] <- medianSilver
# zavrsili smo sredjivanje podataka, sada pravimo korelacionu matricu
matrica <- cor(data)
library(corrplot)
corrplot(matrica, method = "number", type = "upper", diag = F)
# vidimo da su sve 3 varijable visoko korelisane
# napravicemo model sa sve 3, pa cemo videti kakve rezultate nam daje
library(caret)
set.seed(1010)
indexes <- createDataPartition(data$Gold, p = 0.8, list = FALSE)
train.data <- data[indexes, ]
test.data <- data[-indexes, ]
lm1 <- lm(Gold ~ ., data = train.data)
summary(lm1)
# za svako povecanje Silver povecava nam se Gold za 0.657 zlatnih medalja
# za svako povecanje Bronze povecava nam se Gold za 0.253 zlatnih medalja
# izgled linearne krive y = -0.09714 + 0.0657x + 0.253y
# max zvezdica je 3, sto veci broj zvezdica, to je znacajnija predikcija
# ovde vidimo da su nam obe varijable znacajne
# intercept znaci kolika bi vrednost bila da su svi prediktori 0 (nije uvek realno)
# residual predstavlja razliku izmedju stvarnih i predvidjenih vrednosti
# i ovde iznosi 1.671
# r-squared znaci da nas model objasnjava 92.2% varijabilieteta zavisne promenljive Gold
# f-statistika je 413.8, a p-value < 0.05, dakle postoji zavisnost izmedju
# zavisne promenljive i prediktora i ima smisla razmatrati ovaj nas model
# pravimo 4 plota
graphics.off()
par(mfrow = c(1,1))
par(mfrow = c(2,2))
plot(lm1)
