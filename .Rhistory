str(data)
table(data$GoingTo)
summary(data)
data$GoingTo[data$GoingTo == "" | data$GoingTo == "-"] <- NA
data$GoingTo[is.na(data$GoingTo)] <- "Work"
data$GoingTo <- as.factor(data$GoingTo)
data$DayOfWeek <- as.factor(data$DayOfWeek)
table(data$FuelEconomy)
data$FuelEconomy[data$FuelEconomy == "" | data$FuelEconomy == "-"] <- NA
length(which(is.na(data$FuelEconomy)))
data$FuelEconomy <- as.numeric(data$FuelEconomy)
class(data$FuelEconomy)
shapiro.test(data$FuelEconomy)
medijanaFuelEco <- median(data$FuelEconomy, na.rm = TRUE)
medijanaFuelEco
table(data$FuelEconomy)
length(which(is.na(data$FuelEconomy)))
data$FuelEconomy[data$FuelEconomy == "" | data$FuelEconomy == "-"] <- NA
length(which(is.na(data$FuelEconomy)))
data$FuelEconomy <- as.numeric(data$FuelEconomy)
class(data$FuelEconomy)
shapiro.test(data$FuelEconomy)
medijanaFuelEco <- median(data$FuelEconomy, na.rm = TRUE)
medijanaFuelEco
data$FuelEconomy[is.na(data$FuelEconomy)] <- medijanaFuelEco
# kreiranje izlazne varijable
data$Take407All <- ifelse(data$Congestion407 < 0.61 & data$Comments == "", yes = "Yes", no = "No")
data$Take407All <- factor(data$Take407All)
data$Congestion407 <- NULL
data$Comments <- NULL
data$Date <- NULL
data$DayOfWeek <- NULL
data$StartTime <- NULL
str(data)
# kad sredimo podatke, kreiramo trening i test set
install.packages('caret')
library(caret)
set.seed(1010)
indexes <- createDataPartition(data$Take407All, p = 0.8, list = FALSE)
train.data <- data[indexes, ]
test.data <- data[-indexes, ]
# nakon toga, rpart u cheatsheetu
library(rpart)
tree1 <- rpart(Take407All ~ . ,
data = train.data,
method = "class")
tree1 <- rpart(Take407All ~ . ,
data = train.data,
method = "class")
# pravimo predikciju
tree1.pred <- predict(tree1, newdata = test.data, type = "class")
# pravimo konfuzionu matricu
tree1.cm <- table(true = test.data$Take407All, predicted = tree1.pred)
tree1.cm
class(tree1.cm)
# napisemo funkciju za evaluaciju i odradimo je na cm
# OVO MORAMO SAMI, OVO JE KAD JE YES POZITIVNA, SAMO OBRNES KAD JE NO POZITIVNA
getEvaluationMetrics <- function(cm){
TP <- cm[2,2]
TN <- cm[1,1]
FP <- cm[1,2]
FN <- cm[2,1]
accuracy = sum(diag(cm))/sum(cm)
precision <- TP / (TP + FP)
recall <- TP / (TP + FN)
F1 <- (2 * precision * recall) / (precision + recall)
c(Accuracy = accuracy,
Precision = precision,
Recall = recall,
F1 = F1)
}
eval.tree1 <- getEvaluationMetrics(tree1.cm)
eval.tree1
# poslednji deo cross validacija <folds> cheatsheet
library(e1071)
library(caret)
numFolds = trainControl(method = "cv", number = 10) # KREIRATI NOVO STABLO U 10 ITERACIJA PA ZATO 10
cpGrid = expand.grid(.cp = seq(from = 0.001, to = 0.05, by = 0.001)) # ovi brojevi uvek
set.seed(1010) # OVO JE JAKO BITNO PRE KROS VALIDACIJE !
crossvalidation <- train(Take407All ~ . ,
data = train.data,
method = "rpart",
control = rpart.control(minsplit = 10),
trControl = numFolds,
tuneGrid = cpGrid)
crossvalidation
plot(crossvalidation)
# PRUNE JE U CHEATSHEETU
tree2 <- prune(tree1, cp = 0.05)
tree2.pred <- predict(tree2, newdata = test.data, type = "class")
# PRUNE JE U CHEATSHEETU
tree2 <- prune(tree1, cp = 0.05)
tree2.pred <- predict(tree2, newdata = test.data, type = "class")
tree2.cm <- table(true = test.data$Take407All, predicted = tree2.pred) # OVO NEMA U CHEATSHEETU
eval.tree2 <- getEvaluationMetrics(tree2.cm)
eval.tree1
eval.tree2
data.frame(rbind(eval.tree1, eval.tree2), row.names = c("prvi","drugi"))
data <- read.csv("travel-times.csv")
data$Date <- NULL
data$StartTime <- NULL
data$DayOfWeek <- NULL
data$GoingTo <- NULL
summary(data)
apply(data, 2, FUN = function(x) length(which(is.na(x))))
apply(data, 2, FUN = function(x) length(which(x == "")))
apply(data, 2, FUN = function(x) length(which(x == "-")))
str(data)
apply(data, 2, FUN = function(x) length(which(is.na(x) | x == "")))
apply(data, 2, FUN = function(x) length(which(is.na(x))))
apply(data, 2, FUN = function(x) length(which(x == "")))
apply(data, 2, FUN = function(x) length(which(x == "-")))
apply(data, 2, FUN = function(x) length(which(x == "" | x == "-")))
str(data)
data$GoingTo[data$GoingTo == ""] <- NA
table(data$GoingTo)
data$GoingTo[is.na(data$GoingTo)] <- "Work"
data$GoingTo <- as.numeric(data$GoingTo)
data <- read.csv("travel-times.csv")
summary(data)
apply(data, 2, FUN = function(x) length(which(is.na(x))))
apply(data, 2, FUN = function(x) length(which(x == "")))
apply(data, 2, FUN = function(x) length(which(x == "-")))
str(data)
data$GoingTo[data$GoingTo == ""] <- NA
table(data$GoingTo)
data$GoingTo[is.na(data$GoingTo)] <- "Work"
data$GoingTo <- as.numeric(data$GoingTo)
data <- read.csv("travel-times.csv")
summary(data)
apply(data, 2, FUN = function(x) length(which(is.na(x))))
apply(data, 2, FUN = function(x) length(which(x == "")))
apply(data, 2, FUN = function(x) length(which(x == "-")))
str(data)
View(data)
data$GoingTo[data$GoingTo == ""] <- NA
table(data$GoingTo)
data$GoingTo[is.na(data$GoingTo)] <- "Work"
data$GoingTo <- as.numeric(data$GoingTo)
data$GoingTo <- as.factor(data$GoingTo)
data$GoingTo <- as.numeric(data$GoingTo)
summary(data)
View(data)
data <- read.csv("travel-times.csv")
summary(data)
apply(data, 2, FUN = function(x) length(which(is.na(x))))
apply(data, 2, FUN = function(x) length(which(x == "")))
apply(data, 2, FUN = function(x) length(which(x == "-")))
str(data)
data$GoingTo[data$GoingTo == ""] <- NA
table(data$GoingTo)
data$GoingTo[is.na(data$GoingTo)] <- "Work"
data$GoingTo <- as.numeric(data$GoingTo)
View(data)
data$FuelEconomy[data$FuelEconomy == "" | data$FuelEconomy == "-"] <- NA
class(data$FuelEconomy)
data$FuelEconomy <- as.numeric(data$FuelEconomy)
View(data)
shapiro.test(data$FuelEconomy)
medijanaFuelEco <- median(data$FuelEconomy, na.rm = TRUE)
#nema normlanu raspodelu, pa NA menjam sa medijanom
data$FuelEconomy[is.na(data$FuelEconomy)] <- medijanaFuelEco
data$Date <- NULL
data$StartTime <- NULL
data$DayOfWeek <- NULL
data$GoingTo <- NULL
str(data)
# 60ti percentil Congestion407
# quantile ima u CHEATSHEETu
percentil60 <- quantile(data$Congestion407, 0.6)
percentil60
data$Take407All <- ifelse(data$Congestion407 < percentil60 & data$Comments == "", yes = "Yes", no = "No")
data$Congestion407 <- NULL
data$Comments <- NULL
str(data)
data$Take407All <- factor(data$Take407All)
# gledamo koliko ima outlajera
apply(X = data[,1:7], 2, FUN = function(x) length(boxplot.stats(x)$out))
# posto ima outlajera moramo standardizaciju
apply(X = data[,1:7], 2, FUN = function(x) shapiro.test(x))
# 60ti percentil Congestion407
# quantile ima u CHEATSHEETu
percentil60 <- quantile(data$Congestion407, 0.6)
data$Take407All <- ifelse(data$Congestion407 < percentil60 & data$Comments == "", yes = "Yes", no = "No")
data$Congestion407 <- NULL
data$Comments <- NULL
str(data)
data$Take407All <- factor(data$Take407All)
# gledamo koliko ima outlajera
apply(X = data[,1:7], 2, FUN = function(x) length(boxplot.stats(x)$out))
# posto ima outlajera moramo standardizaciju
apply(X = data[,1:7], 2, FUN = function(x) shapiro.test(x))
# sve p vrednosti su manje od 0.05, pa je center = median(x) scale = IQR(x)
# ako je neka veca od 0.05, odnosno ima normalnu raspodelu onda pisemo center = TRUE scale = TRUE
# naravno izbaci kolone koje ne trebaju u odredjenoj funkciji
data.std <- apply(X = data[,1:7], 2, FUN = function(x) scale(x, center = median(x), scale = IQR(x)))
# sve p vrednosti su manje od 0.05, pa je center = median(x) scale = IQR(x)
# ako je neka veca od 0.05, odnosno ima normalnu raspodelu onda pisemo center = TRUE scale = TRUE
# naravno izbaci kolone koje ne trebaju u odredjenoj funkciji
data.std <- apply(X = data[,1:7], 2, FUN = function(x) scale(x, center = median(x), scale = IQR(x)))
data.std <- as.data.frame(data.std)
# sad dodamo Take407All jer je ona ta poslednja, factor varijabla
data.std$Take407All <- as.factor(data$Take407All)
str(data.std)
# kad smo zavrsili sa standardizacijom, delimo na train i test
library(caret)
set.seed(1010)
indexes <- createDataPartition(data.std$Take407All, p = 0.8, list = FALSE)
train.data <- data.std[indexes, ]
test.data <- data.std[-indexes, ]
# krosvalidacija za 10 iteracija, kako je dato u zadatku
# nacin za pronalazenje sto boljih vrednosti za parametre
# za krosvalidaciju uvek e1071 !!!
library(e1071)
library(caret)
numFolds = trainControl(method = "cv", number = 10)
kGrid = expand.grid(.k = seq(from = 3, to = 25, by = 2))
# OBAVEZNO SET.SEED !!!
set.seed(1010)
knn.cv <- train(Take407All ~ . ,
data = train.data,
method = "knn",
trControl = numFolds, tuneGrid = kGrid)
knn.cv
plot(knn.cv)
View(knn.cv)
class(knn.cv)
library(class)
knn.pred <- knn(train = train.data[,-8], # training data without the output (class) variable
test = test.data[,-8], # test data without the output (class) variable
cl = train.data$Take407All, # output (class) variable is specified here
k = 23)
getEvaluationMetrics <- function(cm){
TP <- cm[2,2]
TN <- cm[1,1]
FP <- cm[1,2]
FN <- cm[2,1]
accuracy <- sum(diag(cm)) / sum(cm)
precision <- TP / (TP + FP)
recall <- TP / (TP + FN)
F1 <- (2*precision*recall) / (precision + recall)
c(Accuracy = accuracy,
Precision = precision,
Recall = recall,
F1 = F1)
}
knn.cm <- table(true = test.data$Take407All, predicted = knn.pred)
knn.cm
knn.eval <- getEvaluationMetrics(knn.cm)
knn.eval
dataNB <- read.csv("winemag-data-130k-v2-custom.csv", stringsAsFactors = FALSE)
str(dataNB)
dataNB <- read.csv("winemag-data-130k-v2-custom.csv", stringsAsFactors = FALSE)
str(dataNB)
gc()
dataNB <- read.csv("winemag-data-130k-v2-custom.csv", stringsAsFactors = FALSE)
str(dataNB)
View(dataNB)
dataNB <- read.csv("winemag-data-130k-v2-custom.csv", stringsAsFactors = FALSE)
str(dataNB)
dataSub <- subset(dataNB, (country == "France" | country == "Argentina" | country == "Italy"))
summary(dataSub)
subset()?
dataSub <- subset(dataNB, (country == "France" | country == "Argentina" | country == "Italy"))
subset?
dataSub <- subset(dataNB, (country == "France" | country == "Argentina" | country == "Italy"))
dataSub <- subset(dataNB, (country == "France" | country == "Argentina" | country == "Italy"))
summary(dataSub)
apply(dataSub, 2, FUN = function(x) length(which(x == "")))
apply(dataSub, 2, FUN = function(x) length(which(x == "-")))
apply(dataSub, 2, FUN = function(x) length(which(is.na(x))))
length(unique(dataSub$designation))
dataSub$region_2 <- NULL
length(unique(dataSub$designation))
# posto designation ima 1877 razl vrednosti a ukupan br observacije je 3427 nema poente
# da je pretvorimo u faktor zato cemo je ukloniti
dataSub$designation <- NULL
length(unique(dataSub$region_1))
View(dataSub)
# posto designation ima 1877 razl vrednosti a ukupan br observacije je 3427 nema poente
# da je pretvorimo u faktor zato cemo je ukloniti
dataSub$designation <- NULL
length(unique(dataSub$region_1))
# posto ima mnogo faktora brisemo
dataSub$region_1 <- NULL
dataSub$description <- NULL #description nema uticaja na dalje analze
dataSub$country <- as.factor(dataSub$country)
dataSub$title <- NULL
length(unique(dataSub$province))
dataSub$province <- as.factor(dataSub$province)
str(dataSub)
length(unique(dataSub$variety))
dataSub$variety <- as.factor(dataSub$variety)
length(unique(dataSub$winery))
dataSub$winery <- NULL
str(dataSub)
shapiro.test(dataSub$price)
medijana <- median(dataSub$price, na.rm = TRUE)
dataSub$price[is.na(dataSub$price)] <- medijana
str(dataSub)
prvikvartil <- quantile(dataSub$price, 0.25)
prvikvartil
dataSub$price_category <- ifelse(dataSub$price <= prvikvartil, yes = "cheap", no = "not_cheap")
dataSub$price <- NULL
dataSub$price <- NULL
str(dataSub)
dataSub$price_category <- as.factor(dataSub$price_category)
str(dataSub)
shapiro.test(dataSub$points)
install.packages("bnlearn")
library(bnlearn)
dataSub$points <- as.numeric(dataSub$points)
points.df <- as.data.frame(dataSub$points)
View(points.df)
discretized <- discretize(data = points.df,
method = "quantile",
breaks = c(5))
library(bnlearn)
dataSub$points <- as.numeric(dataSub$points)
points.df <- as.data.frame(dataSub$points)
discretized <- discretize(data = points.df,
method = "quantile",
breaks = c(5))
levels(discretized$`dataSub$points`)
newData <- as.data.frame(cbind(dataSub[,1:5],discretized))
View(newData)
# spojimo ove sa normalnom i faktor varijable sa ovom diskretizovanom u newData
str(newData)
summary(newData)
newData$points <- newData$`dataSub$points`
newData$`dataSub$points` <- NULL
summary(newData)
install.packages("e1071")
install.packages("e1071")
library(e1071)
nb1 <- naiveBayes(price_category ~ ., data = train.set)
nb1
nb1.pred <- predict(nb1, newdata = test.set, type = "class")
nb1.cm <- table(true = test.set$price_category, predicted = nb1.pred)
#train i test
library(caret)
set.seed(10)
indexes <- createDataPartition(newData$price_category, p= 0.80, list = F)
train.set <- newData[indexes,]
test.set <- newData[-indexes,]
install.packages("e1071")
library(e1071)
install.packages("e1071")
nb1 <- naiveBayes(price_category ~ ., data = train.set)
nb1 <- naiveBayes(price_category ~ ., data = train.set)
nb1
nb1.pred <- predict(nb1, newdata = test.set, type = "class")
nb1.cm <- table(true = test.set$price_category, predicted = nb1.pred)
nb1.cm
install.packages("e1071")
library(e1071)
nb1 <- naiveBayes(price_category ~ ., data = train.set)
nb1
nb1.pred <- predict(nb1, newdata = test.set, type = "class")
nb1.cm <- table(true = test.set$price_category, predicted = nb1.pred)
nb1.cm
install.packages("e1071")
install.packages("e1071")
nb1.cm
getEvaluationMetrics <- function(cm) {
TP <- cm[2,2] # true positive
TN <- cm[1,1] # true negative
FP <- cm[1,2] # false positive
FN <- cm[2,1] # false negative
accuracy <- sum(diag(cm)) / sum(cm)
precision <- TP / (TP + FP)
recall <- TP / (TP + FN)
F1 <- (2 * precision * recall) / (precision + recall)
c(Accuracy = accuracy,
Precision = precision,
Recall = recall,
F1 = F1)
}
nb1.eval <- getEvaluationMetrics(nb1.cm)
nb1.eval
# sad trazimo threshold preko ROC krive
# to je optimalna verovatnoca za specificity i sensitivity
# onda se pravi nova predikcija za ROC krivu, ali TYPE = RAW
nb2.pred.prob <- predict(nb1, newdata = test.set, type = "raw")
nb2.pred.prob
#kreiranje ROC krive
install.packages("pROC")
library(pROC)
nb2.roc <- roc(response = as.numeric(test.set$price_category),
predictor = nb2.pred.prob[,2],
levels = c(1,2))
# kada je no pozitivna klasa onda ide predictor = nb2.pred.prob[,1],levels = c(2,1)
nb2.roc$auc
library(pROC)
nb2.roc <- roc(response = as.numeric(test.set$price_category),
predictor = nb2.pred.prob[,2],
levels = c(1,2))
# sad trazimo threshold preko ROC krive
# to je optimalna verovatnoca za specificity i sensitivity
# onda se pravi nova predikcija za ROC krivu, ali TYPE = RAW
nb2.pred.prob <- predict(nb1, newdata = test.set, type = "raw")
nb2.pred.prob
dataNB <- read.csv("winemag-data-130k-v2-custom.csv", stringsAsFactors = FALSE)
str(dataNB)
dataSub <- subset(dataNB, (country == "France" | country == "Argentina" | country == "Italy"))
summary(dataSub)
apply(dataSub, 2, FUN = function(x) length(which(x == "")))
apply(dataSub, 2, FUN = function(x) length(which(x == "-")))
apply(dataSub, 2, FUN = function(x) length(which(is.na(x))))
dataSub$region_2 <- NULL
length(unique(dataSub$designation))
# posto designation ima 1877 razl vrednosti a ukupan br observacije je 3427 nema poente
# da je pretvorimo u faktor zato cemo je ukloniti
dataSub$designation <- NULL
length(unique(dataSub$region_1))
# posto ima mnogo faktora brisemo
dataSub$region_1 <- NULL
dataSub$description <- NULL #description nema uticaja na dalje analze
dataSub$country <- as.factor(dataSub$country)
dataSub$title <- NULL
length(unique(dataSub$province))
dataSub$province <- as.factor(dataSub$province)
str(dataSub)
length(unique(dataSub$variety))
dataSub$variety <- as.factor(dataSub$variety)
length(unique(dataSub$winery))
dataSub$winery <- NULL
str(dataSub)
shapiro.test(dataSub$price)
medijana <- median(dataSub$price, na.rm = TRUE)
dataSub$price[is.na(dataSub$price)] <- medijana
str(dataSub)
prvikvartil <- quantile(dataSub$price, 0.25)
prvikvartil
dataSub$price_category <- ifelse(dataSub$price <= prvikvartil, yes = "cheap", no = "not_cheap")
dataSub$price <- NULL
dataSub$price_category <- as.factor(dataSub$price_category)
str(dataSub)
shapiro.test(dataSub$points)
install.packages("bnlearn")
library(bnlearn)
dataSub$points <- as.numeric(dataSub$points)
points.df <- as.data.frame(dataSub$points)
discretized <- discretize(data = points.df,
method = "quantile",
breaks = c(5))
levels(discretized$`dataSub$points`)
newData <- as.data.frame(cbind(dataSub[,1:5],discretized))
# spojimo ove sa normalnom i faktor varijable sa ovom diskretizovanom u newData
str(newData)
summary(newData)
newData$points <- newData$`dataSub$points`
newData$`dataSub$points` <- NULL
#train i test
library(caret)
set.seed(10)
indexes <- createDataPartition(newData$price_category, p= 0.80, list = F)
train.set <- newData[indexes,]
test.set <- newData[-indexes,]
install.packages("e1071")
library(e1071)
nb1 <- naiveBayes(price_category ~ ., data = train.set)
nb1
nb1.pred <- predict(nb1, newdata = test.set, type = "class")
nb1.cm <- table(true = test.set$price_category, predicted = nb1.pred)
nb1.cm
getEvaluationMetrics <- function(cm) {
TP <- cm[2,2] # true positive
TN <- cm[1,1] # true negative
FP <- cm[1,2] # false positive
FN <- cm[2,1] # false negative
accuracy <- sum(diag(cm)) / sum(cm)
precision <- TP / (TP + FP)
recall <- TP / (TP + FN)
F1 <- (2 * precision * recall) / (precision + recall)
c(Accuracy = accuracy,
Precision = precision,
Recall = recall,
F1 = F1)
}
nb1.eval <- getEvaluationMetrics(nb1.cm)
nb1.eval
# sad trazimo threshold preko ROC krive
# to je optimalna verovatnoca za specificity i sensitivity
# onda se pravi nova predikcija za ROC krivu, ali TYPE = RAW
nb2.pred.prob <- predict(nb1, newdata = test.set, type = "raw")
nb2.pred.prob
#kreiranje ROC krive
install.packages("pROC")
install.packages("pROC")
library(pROC)
nb2.roc <- roc(response = as.numeric(test.set$price_category),
predictor = nb2.pred.prob[,2],
levels = c(1,2))
# kada je no pozitivna klasa onda ide predictor = nb2.pred.prob[,1],levels = c(2,1)
nb2.roc$auc
# sto je area under the curve veca, to je bolja 0.8434 je u nasem slucaju
# sada pravimo plot da bismo videli threshold
plot.roc(nb2.roc, print.thres = TRUE, print.thres.best.method = "youden")
nb2.coords <- coords(nb2.roc,
ret = c("accuracy", "spec", "sens", "thr"),
x = "local maximas")
nb2.coords
prob.threshold <- nb2.coords[54,4]
prob.threshold
nb2.pred <- ifelse(test = nb2.pred.prob[,2] >= prob.threshold, yes = "Cheap", no = "Not_cheap")
nb2.pred <- as.factor(nb2.pred)
nb2.cm <- table(true = test.set$price_category, predicted = nb2.pred)
nb2.cm
nb2.eval <- getEvaluationMetrics(nb2.cm)
nb2.eval
data.frame(rbind(nb1.eval, nb2.eval), row.names = c("one", "two"))
